///////////////////////////////////////////////////////////////////////////////
// researched and coded by Konstantin Isakov
///////////////////////////////////////////////////////////////////////////////
void HardFault_Handler()
{
    // Adjust PC register value stored on stack,
    // so interrupt will return to the instruction next to faulty one.
    // These three instructions, plus "bx, lr" generated by compiler
    // consume 5 cpu cycles.
    //
    asm(
        "ldr r0, [sp, #0x18]\n"
        "adds r0, r0, #2\n"
        "str r0, [sp, #0x18]\n"
    );
}

static const uint32_t CyclesInsideHandler = 5;
volatile int* BadPtr = (int*)(-1);

void MeausreInterruptLatency()
{
    // Capture current value of the CPU cycle counter.
    //
    uint32_t cpuCycles = StopwatchMark();

    // Trigger Hard Fault interrupt by de-referencing bad pointer.
    //
    if (*BadPtr == 0);

    // Capture updated value of the CPU cycle counter and get the delta.
    //
    cpuCycles = StopwatchRead(cpuCycles);

    // Report on console.
    //
    printf("Hard Fault interrupt took %u CPU cycles.\n", cpuCycles - CyclesInsideHandler);
}
